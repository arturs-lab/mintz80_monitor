# File C:\zeus\mintz80_monitor\Z80Monitor.asm
0000 C3 66 00    R_MAIN:     JP      MAIN            ; init DART and starts command loop
0003 C3 A2 02    R_U_INIT:   JP      UART_INIT       ; configures DARTchannel B 
0006 C3 03 0E    R_PRT_NL:   JP      PRINT_NEW_LINE  ; sends a CR LF
0009 C3 D1 0D    R_PRT_STR:  JP      PRINT_STRING    ; sends a NULL terminated string
000C 00 00 00                DEFS    3   ; spare  entries
000F 00 00 00                DEFS    3
0012 00 00 00                DEFS    3
0015 00 00 00                DEFS    3
# End of file C:\zeus\mintz80_monitor\Z80Monitor.asm
# File C:\zeus\mintz80_monitor\jumptab.asm
0018 C3 A4 0E    jPRINTHBYTE:	jp PRINTHBYTE
001B C3 DC 0D    jPRINT_CHAR:	jp PRINT_CHAR
001E C3 D1 0D    jPRINT_STRING:	jp PRINT_STRING
0021 C3 00 00    jb:	jp 0
0024 C3 00 00    jc:	jp 0
0027 C3 00 00    jd:	jp 0
002A C3 00 00    je:	jp 0
002D C3 00 00    jf:	jp 0
0030 C3 00 00    jg:	jp 0
0033 C3 00 00    jh:	jp 0
0036 C3 00 00    ji:	jp 0
0039 C3 00 00    jj:	jp 0
003C C3 00 00    jk:	jp 0
003F C3 00 00    jl:	jp 0
0042 C3 00 00    jm:	jp 0
0045 C3 00 00    jn:	jp 0
0048 C3 00 00    jo:	jp 0
004B C3 00 00    jq:	jp 0
004E C3 00 00    js:	jp 0
0051 C3 00 00    jt:	jp 0
0054 C3 00 00    ju:	jp 0
0057 C3 00 00    jv:	jp 0
005A C3 00 00    jw:	jp 0
005D C3 00 00    jx:	jp 0
0060 C3 00 00    jy:	jp 0
0063 C3 00 00    jz:	jp 0
# End of file C:\zeus\mintz80_monitor\jumptab.asm
# File C:\zeus\mintz80_monitor\Z80Monitor.asm
0066 F3          	di
0067 3E 7B       	ld a,$7b	; disable wdt
0069 D3 F0       	out ($f0),a
006B 3E B1       	ld a,$b1
006D D3 F1       	out ($f1),a
006F 31 FF FF    	ld sp,RAM_TOP
0072 3E 20       	ld a,$20
0074 CD 0A 0F    	call delay		; looks like Z80 needs this delay to successfully write to IO ports
0077 3E 01       	ld a,$01		; (SYSCLK MHz/2/(value+1))
0079 D3 D0       	out (turbo),a
007B CD 51 0F    	call ayinit
007E 01 00 02    	ld bc,$0200	; bc = duration
0081 3E 06       	ld a,$06		; a = pitch
0083 CD 13 0F    	call beep
0086 21 91 00    dio:	ld hl,hellostr
0089 CD D1 0D    	call PRINT_STRING
008C CD 22 0F    	call dmpio
008F 18 19       	jr gomain
0091 0D 0A 48 65 6C 6C 6F 72 6C 64 0D 0A 43 50 4C 44 20 63 6F 6E 66 69 67 3A 00 hellostr:	db $0d,$0a,"Hellorld",$0d,$0a,"CPLD config:",0
00AA 31 FF FF    gomain:	LD SP,RAM_TOP		;Load the stack pointer for stack operations.
00AD CD A2 02    	CALL UART_INIT		;Initialize UART
00B0 CD A4 01    	CALL PRINT_MON_HDR	;Print the monitor header info
00B3 3E 00       	LD A, 00h
00B5 32 11 FE    	LD (DMPADDR), A
00B8 3E FF       	LD A, 0FFh		; FF00h and next should result in 0000h
00BA 32 12 FE    	LD (DMPADDR+1), A
00BD CD 9A 02    	CALL CLEAR_ERROR
00C0 CD D3 01    	CALL MON_PRMPT_LOOP	;Monitor user prompt loop
00C3 76          	HALT
00C4 21 06 0F    	LD HL,MON_CLS
00C7 CD D1 0D    	CALL PRINT_STRING
00CA C9          	RET
00CB C3 00 00    	JP MPFMON		;Jumps to 0000 (MPF-1 monitor re-entry)	
00CE 0D 0A 4D 69 6E 74 5A 38 30 20 43 6F 6D 70 75 74 65 72 09 09 09 32 30 31 35 20 4D 43 6F 6F 6B MNMSG1:     DEFB    0DH, 0Ah, "MintZ80 Computer", 09h, 09h, 09h, "2015 MCook"
00ED 0D 0A 20 61 64 61 70 74 61 74 69 6F 6E 20 74 6F 20 4D 50 46 2D 31 20 2F 20 5A 38 30 20 44 41 52 54 09 32 30 32 32 20 46 2E 4A 2E 4B 72 61 61 6E 0D 0A MNMSG2:     DEFB    0DH, 0Ah, " adaptation to MPF-1 / Z80 DART", 09h, "2022 F.J.Kraan", 0Dh, 0Ah
011F 41 64 61 70 74 61 74 69 6F 6E 20 74 6F 20 4D 69 6E 74 5A 38 30 20 32 30 32 35 20 41 72 74 75 72 27 73 20 4C 61 62 0D 0A             DEFB    "Adaptation to MintZ80 2025 Artur's Lab", 0Dh, 0Ah
0147 4D 6F 6E 69 74 6F 72 20 76 31 2E 30 2C 20 52 4F 4D 3A 20 00 MNMSG3A:    DEFB    "Monitor v", VERSMYR, ".", VERSMIN, ", ROM: ", EOS
015B 68 2C 20 52 41 4D 3A 20 00 MNMSG3B:    DEFB    "h, RAM: ", EOS
0164 68 2C 20 44 41 52 54 3A 20 00 MNMSG3C:    DEFB    "h, DART: ", EOS
016E 68 0D 0A 0D 0A MNMSG3D:    DEFB    "h", 0Dh, 0AH, 0Dh, 0AH
0173 09 20 49 6E 70 75 74 20 3F 20 66 6F 72 20 63 6F 6D 6D 61 6E 64 20 6C 69 73 74 0D 0A 00 MONHLP:     DEFB    09h," Input ? for command list", 0Dh, 0AH, EOS
0190 0D 0A 45 72 72 6F 72 20 69 6E 20 70 61 72 61 6D 73 3A 20 00 MONERR:     DEFB    0Dh, 0AH, "Error in params: ", EOS
01A4 CD C4 00            CALL    CLEAR_SCREEN        ;Clear the terminal screen
01A7 21 CE 00            LD      HL, MNMSG1          ;Print some messages
01AA CD D1 0D            CALL    PRINT_STRING
01AD 21 00 00            LD      HL, ROM_BOTTOM
01B0 CD B5 0E            CALL    PRINTHWORD
01B3 21 5B 01            LD      HL, MNMSG3B         ; 2nd part, RAM
01B6 CD D1 0D            CALL    PRINT_STRING
01B9 21 00 20            LD      HL, RAM_BOTTOM
01BC CD B5 0E            CALL    PRINTHWORD
01BF 21 64 01            LD      HL, MNMSG3C         ; 3rd part UART
01C2 CD D1 0D            CALL    PRINT_STRING
01C5 3E 08               LD      A, UART_BASE
01C7 CD A4 0E            CALL    PRINTHBYTE
01CA 21 6E 01            LD      HL, MNMSG3D         ; 4th part, line ending
01CD CD D1 0D            CALL    PRINT_STRING
01D0 C9                  RET
01D1 3E 00       MON_PROMPT: DEFB ">", EOS
01D3 3E 00               LD      A, 00h
01D5 32 19 FE            LD      (MUTE), A       ; Enables echo of received chars
01D8 21 D1 01            LD      HL,MON_PROMPT   ; Print monitor prompt
01DB CD D1 0D            CALL    PRINT_STRING
01DE CD D5 0D            CALL    GET_CHAR        ; Get a character from user into Acc
01E1 CD DC 0D            CALL    PRINT_CHAR
01E4 FE 0D               CP      CR
01E6 28 03               JR      Z, _MPL_CR
01E8 CD 03 0E            CALL    PRINT_NEW_LINE  ; Print a new line
01EB CD F3 01            CALL    MON_COMMAND     ; Respond to user input
01EE CD 03 0E            CALL    PRINT_NEW_LINE  ; Print a new line
01F1 18 E0               JR      MON_PRMPT_LOOP
01F3 CD 9A 02            CALL    CLEAR_ERROR
01F6 FE 3F               CP      "?"
01F8 CC 3E 05            CALL    Z,HELP_COMMAND
01FB FE 44               CP      "D"
01FD CC AE 05            CALL    Z,MDCMD
0200 FE 43               CP      "C"
0202 CC C4 00            CALL    Z,CLEAR_SCREEN
0205 FE 4E               CP      "N"
0207 CC 51 08            CALL    Z,RICOMMAND
020A FE 4F               CP      "O"
020C CC 9F 08            CALL    Z,PW_COMMAND
020F FE 50               CP      "P"
0211 CC CF 07            CALL    Z,PSCOMMAND
0214 FE 51               CP      "Q"
0216 CC 59 02            CALL    Z,UTERMTST
0219 FE 52               CP      "R"
021B CC CB 00            CALL    Z,RESET_COMMAND
021E FE 4D               CP      "M"
0220 CC 51 06            CALL    Z,MOVE_COMMAND
0223 FE 46               CP      "F"
0225 CC F3 06            CALL    Z,FILL_COMMAND
0228 FE 47               CP      "G"
022A CC FB 08            CALL    Z,GO_COMMAND
022D FE 4B               CP      "K"
022F CC 2A 09            CALL    Z,CL_COMMAND
0232 FE 2B               CP      "+"
0234 CC 63 07            CALL    Z,NEXTP_COMMAND
0237 FE 2D               CP      "-"
0239 CC 73 07            CALL    Z,PREVP_COMMAND
023C FE 45               CP      "E"
023E CC 83 07            CALL    Z,EDIT_COMMAND
0241 FE 3A               CP      ":"
0243 CC 08 0A            CALL    Z,HEXI_COMMAND
0246 FE 53               CP      "S"
0248 CC 96 09            CALL    Z,CCKSM_COMMAND
024B FE 54               CP      "T"
024D CC 14 0C            CALL    Z, TRAM_COMMAND
0250 FE 5A               CP      "Z"
0252 CC D2 0A            CALL    Z,REGDUMP_COMMAND
0255 CD 85 02            CALL    ERROR_CHK
0258 C9                  RET
0259 CD DD 02    UTERMTST:	CALL    RX_CHK
025C C0                  RET     NZ      ; Return on serial received char
025D DD 21 7F 02         LD      IX, SCTXT
0261 CD FE 05            CALL    SCAN
0264 FE 10               CP      010h    ; A - 010h
0266 38 0A               JR      C, _UTHEX
0268 CD A4 0E            CALL    PRINTHBYTE
026B 3E 20               LD      A, " "
026D CD DC 0D            CALL    PRINT_CHAR
0270 18 E7               JR      UTERMTST
0272 CD 89 0E            CALL    NIB2CHAR
0275 CD DC 0D            CALL    PRINT_CHAR
0278 3E 20               LD      A, " "
027A CD DC 0D            CALL    PRINT_CHAR
027D 18 DA               JR      UTERMTST
027F 87          SCTXT   DB      10000111b    ; t
0280 AE                  DB      10101110b    ; S
0281 87                  DB      10000111b    ; t
0282 43                  DB      01000011b    ; r.
0283 8F                  DB      10001111b    ; E
0284 AE                  DB      10101110b    ; S
0285 3A 18 FE    ERROR_CHK:	LD      A, (ERRFLAG)
0288 FE 00               CP      E_NONE
028A C8                  RET     Z
028B 21 90 01            LD      HL, MONERR
028E CD D1 0D            CALL    PRINT_STRING
0291 3A 18 FE            LD      A, (ERRFLAG)
0294 CD A4 0E            CALL    PRINTHBYTE
0297 CD 03 0E            CALL    PRINT_NEW_LINE
029A F5          CLEAR_ERROR:	PUSH    AF
029B 3E 00               LD      A, E_NONE
029D 32 18 FE            LD      (ERRFLAG), A
02A0 F1                  POP     AF
02A1 C9                  RET
# End of file C:\zeus\mintz80_monitor\Z80Monitor.asm
# File C:\zeus\mintz80_monitor\UARTDriver.asm
02A2 3E 80                   LD     A,80h				;Mask to Set DLAB Flag
02A4 D3 0B       			OUT    (UART3),A
02A6 3E 0C       			LD     A,12					;Divisor = 12 @ 9600bps w/ 1.8432 Mhz
02A8 D3 08       			OUT    (UART0),A			;Set BAUD rate to 9600
02AA 3E 00       			LD     A,00
02AC D3 09       			OUT    (UART1),A			;Set BAUD rate to 9600
02AE 3E 03       			LD     A,03h
02B0 D3 0B       			OUT    (UART3),A			;Set 8-bit data, 1 stop bit, reset DLAB Flag
02B2 3E 00       			LD	   A,00h
02B4 D3 09       			OUT    (UART1),A			;no interrupts
02B6 C9          			RET		
02B7 F5          			PUSH	AF
02B8 7E          			LD		A,(HL)
02B9 FE 00                   CP		EOS					;Test for end byte
02BB 28 06                   JR		Z,UART_END_PRNT_STR	;Jump if end byte is found
02BD CD CE 02    			CALL	UART_TX
02C0 23                      INC		HL					;Increment pointer to next char
02C1 18 F5                   JR		UARTPRNTSTRLP	;Transmit loop
02C3 F1          			POP		AF
02C4 C9          			RET	 
02C5 F5          UART_TX_RDY:	PUSH 	AF
02C6 DB 0D       			IN		A,(UART5)			;Fetch the control register
02C8 CB 6F       			BIT 	5,A					;Bit will be set if UART is ready to send
02CA 28 FA       			JR		Z,UARTTXRDY_LP		
02CC F1          			POP     AF
02CD C9          			RET
02CE CD C5 02    			CALL  UART_TX_RDY			;Make sure UART is ready to receive
02D1 D3 08       			OUT   (UART0),A				;Transmit character in A to UART
02D3 C9          			RET
02D4 F5          UART_RX_RDY:	PUSH 	AF					
02D5 DB 0D       			IN		A,(UART5)			;Fetch the control register
02D7 CB 47       			BIT 	0,A					;Bit will be set if UART is ready to receive
02D9 28 FA       			JR		Z,UART_RXRDY_LP		
02DB F1          			POP     AF
02DC C9          			RET
02DD DB 0D       			IN		A,(UART5)			;Fetch the control register
02DF E6 01       			AND	1					;Mask other bits, has some char arrived?
02E1 C9          			RET
02E2 CD D4 02    			CALL  UART_RX_RDY			;Make sure UART is ready to receive
02E5 DB 08       			IN    A,(UART0)				;Receive character in UART to A
02E7 C9          			RET			
02E8 3E 55       uart_test	ld a,$55
02EA D3 0F       	out (UART7),a
02EC DB 0F       	in a,(UART7)
02EE FE 55       	cp a,$55
02F0 20 0A       	jr nz,ut1
02F2 3E AA       	ld a,$aa
02F4 D3 0F       	out (UART7),a
02F6 DB 0F       	in a,(UART7)
02F8 FE AA       	cp a,$aa
02FA 28 08       	jr z,ut2
02FC 01 00 04    ut1:	ld bc,$0400	; bc = duration
02FF 3E 04       	ld a,$04		; a = pitch
0301 CD 13 0F    	call beep
0304 C9          ut2:	ret
# End of file C:\zeus\mintz80_monitor\UARTDriver.asm
# File C:\zeus\mintz80_monitor\MONCommands.asm
0305 5A 4D 43 38 30 20 4D 6F 6E 69 74 6F 72 20 43 6F 6D 6D 61 6E 64 20 4C 69 73 74 0D 0A HLPMSG1: DEFB "ZMC80 Monitor Command List", 0Dh, 0Ah
0321 3F 20 2D 20 76 69 65 77 20 63 6F 6D 6D 61 6E 64 20 6C 69 73 74 0D 0A HLPMSG2: DEFB "? - view command list", 0Dh, 0Ah
0338 43 20 2D 20 63 6C 65 61 72 20 73 63 72 65 65 6E 0D 0A HLPMSGc: DEFB "C - clear screen", 0Dh, 0Ah
034A 44 20 2D 20 70 72 69 6E 74 20 31 30 30 68 20 62 79 74 65 73 20 66 72 6F 6D 20 73 70 65 63 69 66 69 65 64 20 6C 6F 63 61 74 69 6F 6E 0D 0A HLPMSGd: DEFB "D - print 100h bytes from specified location", 0Dh, 0Ah
0378 45 20 2D 20 65 64 69 74 20 62 79 74 65 73 20 69 6E 20 6D 65 6D 6F 72 79 0D 0A HLPMSGe: DEFB "E - edit bytes in memory", 0Dh, 0Ah
0392 46 20 2D 20 66 69 6C 6C 20 6D 65 6D 6F 72 79 20 72 61 6E 67 65 20 77 69 74 68 20 76 61 6C 75 65 0D 0A HLPMSGf: DEFB "F - fill memory range with value", 0Dh, 0Ah
03B4 47 20 2D 20 6A 75 6D 70 20 74 6F 20 6D 65 6D 6F 72 79 20 61 64 64 72 65 73 73 0D 0A HLPMSGg: DEFB "G - jump to memory address", 0Dh, 0Ah
03D0 4B 20 2D 20 63 61 6C 6C 20 74 6F 20 6D 65 6D 6F 72 79 20 61 64 64 72 65 73 73 0D 0A HLPMSGk: DEFB "K - call to memory address", 0Dh, 0Ah
03EC 4D 20 2D 20 63 6F 70 79 20 62 79 74 65 73 20 69 6E 20 6D 65 6D 6F 72 79 0D 0A HLPMSGm: DEFB "M - copy bytes in memory", 0Dh, 0Ah
0406 4E 20 2D 20 72 65 61 64 20 49 4F 20 70 6F 72 74 0D 0A          DEFB "N - read IO port", 0Dh, 0Ah
0418 4F 20 2D 20 77 72 69 74 65 20 62 79 74 65 20 74 6F 20 6F 75 74 70 75 74 20 70 6F 72 74 0D 0A HLPMSGo: DEFB "O - write byte to output port", 0Dh, 0Ah
0437 50 20 2D 20 70 72 69 6E 74 20 70 6F 72 74 20 73 63 61 6E 20 28 30 30 2D 46 46 29 0D 0A HLPMSGp: DEFB "P - print port scan (00-FF)", 0Dh, 0Ah
0454 51 20 2D 20 74 65 73 74 20 4D 50 46 20 6B 65 79 62 6F 61 72 64 0D 0A HLPMSGq: DEFB "Q - test MPF keyboard", 0Dh, 0Ah
046B 52 20 2D 20 6D 6F 6E 69 74 6F 72 20 72 65 73 65 74 0D 0A HLPMSGr: DEFB "R - monitor reset", 0Dh, 0Ah
047E 53 20 2D 20 63 61 6C 63 75 6C 61 74 65 20 63 68 65 63 6B 73 75 6D 20 66 6F 72 20 6D 65 6D 6F 72 79 20 72 61 6E 67 65 0D 0A HLPMSGs: DEFB "S - calculate checksum for memory range", 0Dh, 0Ah
04A7 54 20 2D 20 74 65 73 74 20 6D 65 6D 6F 72 79 20 72 61 6E 67 65 0D 0A HLPMSGt: DEFB "T - test memory range", 0Dh, 0Ah
04BE 5A 20 2D 20 64 75 6D 70 20 75 73 65 72 20 72 65 67 69 73 74 65 72 73 20 28 53 54 45 50 29 0D 0A HLPMSGz: DEFB "Z - dump user registers (STEP)", 0Dh, 0Ah
04DE 2B 20 2D 20 70 72 69 6E 74 20 6E 65 78 74 20 62 6C 6F 63 6B 20 6F 66 20 6D 65 6D 6F 72 79 0D 0A HLPMSG8: DEFB "+ - print next block of memory", 0Dh, 0Ah
04FE 2D 20 2D 20 70 72 69 6E 74 20 70 72 65 76 69 6F 75 73 20 62 6C 6F 63 6B 20 6F 66 20 6D 65 6D 6F 72 79 0D 0A HLPMSG9: DEFB "- - print previous block of memory", 0Dh, 0Ah
0522 3A 20 2D 20 4C 6F 61 64 20 68 65 78 2D 69 6E 74 65 6C 20 72 65 63 6F 72 64 0D 0A 00 HLPMSGA: DEFB ": - Load hex-intel record", 0DH, 0AH, EOS
053E 21 05 03            LD      HL, HLPMSG1     ;Print some messages
0541 CD D1 0D            CALL    PRINT_STRING
0544 3E 00               LD      A, EOS          ;Load $FF into Acc so MON_COMMAND finishes
0546 C9                  RET
0547 4D 65 6D 6F 72 79 20 44 75 6D 70 0D 0A MDC_1: DEFB "Memory Dump", 0Dh, 0Ah
0554 4C 6F 63 61 74 69 6F 6E 20 74 6F 20 73 74 61 72 74 20 69 6E 20 34 20 64 69 67 69 74 20 48 45 58 3A 20 00 MDC_2: DEFB "Location to start in 4 digit HEX: ",EOS
0577 20 20 20 20 20 20 30 20 20 31 20 20 32 20 20 33 20 20 34 20 20 35 20 20 36 20 20 37 20 20 38 20 20 39 20 20 41 20 20 42 20 20 43 20 20 44 20 20 45 20 20 46 0D 0A 00 MDC_3: DEFB "      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F", 0Dh, 0Ah, EOS
05AE 21 47 05    			LD 		HL,MDC_1			;Print some messages 
05B1 CD D1 0D    			CALL    PRINT_STRING
05B4 CD 6C 0E    			CALL    GETHEXWORD			;HL now points to databyte location	
05B7 3A 18 FE    			LD		A, (ERRFLAG)
05BA FE 00       			CP		E_NONE
05BC C0          			RET		NZ
05BD 22 11 FE    			LD		(DMPADDR), HL		;Keep address for next/prev.
05C0 E5          			PUSH	HL					;Save HL that holds databyte location on stack
05C1 CD 03 0E    			CALL    PRINT_NEW_LINE		;Print some messages
05C4 CD 03 0E    			CALL    PRINT_NEW_LINE
05C7 21 77 05    			LD 		HL, MDC_3	
05CA CD D1 0D    			CALL    PRINT_STRING
05CD E1          			POP		HL					;Restore HL that holds databyte location on stack
05CE 0E 11       MDNXTPR:	LD		C,HEXLINES			;Register C holds counter of dump lines to print
05D0 11 00 FE    			LD		DE,	ASCDMPBUF
05D3 06 10       			LD		B,16				;Register B holds counter of dump bytes to print
05D5 CD B5 0E    			CALL	PRINTHWORD			;Print dump line address in hex form
05D8 3E 20       			LD		A," "				;Print spacer
05DA CD DC 0D    			CALL	PRINT_CHAR
05DD 0D          			DEC		C					;Decrement C to keep track of number of lines printed
05DE 7E          			LD		A,(HL)				;Load Acc with databyte HL points to
05DF CD A4 0E    			CALL	PRINTHBYTE  		;Print databyte in HEX form 
05E2 CD 08 06    			CALL	CHAR2BUF			;Store ASCII char
05E5 3E 20       			LD		A," "				;Print spacer
05E7 CD DC 0D    			CALL	PRINT_CHAR	
05EA 23          			INC 	HL					;Increase HL to next address pointer
05EB 10 F1       			DJNZ	MDBYTES				;Print 16 bytes out since B holds 16
05ED 3E 20       			LD		A," "				;Print spacer
05EF CD DC 0D    			CALL	PRINT_CHAR			;
05F2 3E 00       			LD		A, EOS
05F4 32 10 FE    			LD		(ASCDMPEND), A		;Make sure there is a EOS
05F7 E5          			PUSH	HL
05F8 21 00 FE    			LD		HL, ASCDMPBUF		;Point HL to ASCII buffer
05FB CD D1 0D    			CALL    PRINT_STRING		;Print buffer
05FE E1          			POP		HL
05FF 41          			LD		B,C					;Load B with C to keep track of number of lines printed
0600 CD 03 0E    			CALL    PRINT_NEW_LINE		;Get ready for next dump line
0603 10 CB       			DJNZ	MDLINE				;Print 16 line out since C holds 16 and we load B with C
0605 3E 00       			LD		A,EOS				;Load $FF into Acc so MON_COMMAND finishes
0607 C9          			RET
0608 CD F7 0D    			CALL	MKPRINT
060B 12          			LD		(DE), A
060C 13          			INC		DE
060D C9          			RET
060E 4D 6F 76 65 20 44 61 74 61 0D 0A 00 MVC_1:	DEFB	"Move Data", 0Dh, 0Ah, EOS
061A 53 74 61 72 74 20 4C 6F 63 61 74 69 6F 6E 3A 20 00 MVC_S:	DEFB	"Start Location: ", EOS
062B 45 6E 64 20 4C 6F 63 61 74 69 6F 6E 3A 20 00 MVC_E:	DEFB	"End Location: ", EOS
063A 44 65 73 74 69 6E 61 74 69 6F 6E 20 4C 6F 63 61 74 69 6F 6E 3A 20 00 MVC_D:	DEFB	"Destination Location: ", EOS
0651 21 0E 06    MOVE_COMMAND:	LD		HL, MVC_1	; Print some messages
0654 CD D1 0D            CALL	PRINT_STRING
0657 21 1A 06            LD		HL, MVC_S
065A CD D1 0D            CALL	PRINT_STRING
065D CD 6C 0E            CALL	GETHEXWORD
0660 3A 18 FE            LD		A, (ERRFLAG)
0663 FE 00               CP		E_NONE
0665 C0                  RET		NZ
0666 22 12 FE            LD		(MVADDR), HL
0669 CD 03 0E            CALL	PRINT_NEW_LINE
066C 21 2B 06            LD		HL, MVC_E
066F CD D1 0D            CALL	PRINT_STRING
0672 CD 6C 0E            CALL	GETHEXWORD
0675 3A 18 FE            LD		A, (ERRFLAG)
0678 FE 00               CP		E_NONE
067A C0                  RET		NZ
067B 22 14 FE            LD		(MVADDR+2), HL
067E CD 03 0E            CALL	PRINT_NEW_LINE
0681 21 3A 06            LD		HL, MVC_D
0684 CD D1 0D            CALL	PRINT_STRING
0687 CD 6C 0E            CALL	GETHEXWORD
068A 3A 18 FE            LD		A, (ERRFLAG)
068D FE 00               CP		E_NONE
068F C0                  RET		NZ
0690 22 16 FE            LD		(MVADDR+4), HL
0693 CD 03 0E            CALL	PRINT_NEW_LINE
0696 21 12 FE            ld		hl, MVADDR
0699 CD BD 06            call	GETP	; Fix BC contents from address, to size
069C DA B7 06            jp		c, MERR
069F ED 5B 16 FE         ld		de, (MVADDR+4)
06A3 ED 52               sbc		hl, de
06A5 30 0B               jr		nc, MVUP
06A7 EB          MVDN:	ex		de, hl
06A8 09                  add		hl, bc
06A9 2B                  dec		hl
06AA EB                  ex		de, hl
06AB 2A 14 FE            ld		hl, (MVADDR+2)
06AE ED B8               lddr
06B0 13                  inc		de
06B1 C9                  RET
06B2 19          MVUP:		add		hl,de
06B3 ED B0               ldir
06B5 1B                  dec		de
06B6 C9                  RET;
06B7 3E 02       MERR:		LD		A, E_PARAM
06B9 32 18 FE            LD		(ERRFLAG), A
06BC C9                  RET;
06BD 5E          GETP:		ld		e, (hl) ; MVADDR
06BE 23                  inc		hl
06BF 56                  ld		d, (hl) ; MVADDR+1
06C0 23                  inc		hl
06C1 4E                  ld		c, (hl) ; MVADDR+2
06C2 23                  inc		hl
06C3 66                  ld		h, (hl) ; MVADDR+3
06C4 69                  ld		l, c
06C5 B7                  or		a
06C6 ED 52               sbc		hl, de
06C8 4D                  ld		c, l
06C9 44                  ld		b, h
06CA 03                  inc		bc
06CB EB                  ex		de, hl
06CC C9                  ret	
06CD 46 69 6C 6C 20 4D 65 6D 6F 72 79 0D 0A 00 MFC_1:	DEFB	"Fill Memory", 0Dh, 0Ah, EOS
06DB 44 61 74 61 20 76 61 6C 75 65 20 28 6F 6E 65 20 62 79 74 65 29 3A 20 00 MFC_D:	DEFB	"Data value (one byte): ", EOS
06F3 21 CD 06    FILL_COMMAND:	LD		HL, MFC_1	; Print some messages
06F6 CD D1 0D            CALL	PRINT_STRING
06F9 21 1A 06            LD		HL, MVC_S	; Start msg.
06FC CD D1 0D            CALL	PRINT_STRING
06FF CD 6C 0E            CALL	GETHEXWORD
0702 3A 18 FE            LD		A, (ERRFLAG)
0705 FE 00               CP		E_NONE
0707 C0                  RET		NZ
0708 22 12 FE            LD		(MVADDR), HL	; Start val.
070B CD 03 0E            CALL	PRINT_NEW_LINE
070E 21 2B 06            LD		HL, MVC_E	; End msg.
0711 CD D1 0D            CALL	PRINT_STRING
0714 CD 6C 0E            CALL	GETHEXWORD
0717 22 14 FE            LD		(MVADDR+2), HL	; End val.
071A 3A 18 FE            LD		A, (ERRFLAG)
071D FE 00               CP		E_NONE
071F C0                  RET		NZ
0720 ED 5B 12 FE         LD		DE, (MVADDR)	; Start
0724 ED 52               SBC		HL, DE		; Make sure end is past start...
0726 38 35               JR		C, F_ORDERR
0728 2A 14 FE            LD		HL, (MVADDR+2)
072B CD 03 0E            CALL	PRINT_NEW_LINE
072E 21 DB 06            LD		HL, MFC_D
0731 CD D1 0D            CALL	PRINT_STRING
0734 CD 44 0E            CALL	GETHEXBYTE
0737 32 16 FE            LD		(MVADDR+4), A
073A 3A 18 FE            LD		A, (ERRFLAG)
073D FE 00               CP		E_NONE
073F C0                  RET		NZ
0740 CD 03 0E            CALL	PRINT_NEW_LINE
0743 ED 5B 12 FE         LD		DE, (MVADDR)	; Start
0747 2A 14 FE            LD		HL, (MVADDR+2)	; End
074A ED 52               SBC		HL, DE			; Size
074C 44                  LD		B, H
074D 4D                  LD		C, L
074E 3A 16 FE            LD		A, (MVADDR+4)	; Fill value
0751 2A 12 FE            LD		HL, (MVADDR)	; First source location
0754 77                  LD		(HL), A			; seed the fill block
0755 ED 5B 12 FE         LD		DE, (MVADDR)	; First dest. location
0759 13                  INC		DE				; 
075A ED B0               LDIR
075C C9                  RET
075D 3E 02               LD		A, E_PARAM
075F 32 18 FE            LD		(ERRFLAG), A
0762 C9                  RET
0763 21 77 05    NEXTP_COMMAND:	LD 		HL,MDC_3	
0766 CD D1 0D            CALL    PRINT_STRING
0769 2A 11 FE            LD		HL, (DMPADDR)
076C 24                  INC		H
076D 22 11 FE            LD		(DMPADDR), HL
0770 C3 CE 05            JP		MDNXTPR
0773 21 77 05    PREVP_COMMAND:	LD 		HL,MDC_3	
0776 CD D1 0D            CALL    PRINT_STRING
0779 2A 11 FE            LD		HL, (DMPADDR)
077C 25                  DEC		H
077D 22 11 FE            LD		(DMPADDR), HL
0780 C3 CE 05            JP		MDNXTPR
0783 21 1A 06    EDIT_COMMAND:	LD 		HL, MVC_S	; Start msg.
0786 CD D1 0D            CALL    PRINT_STRING
0789 CD 6C 0E            CALL	GETHEXWORD	; Get first address
078C 3A 18 FE            LD		A, (ERRFLAG)
078F FE 00               CP		E_NONE
0791 C0                  RET		NZ
0792 3E 3A       EDIT_LP:	LD		A, ":"
0794 CD DC 0D            CALL	PRINT_CHAR
0797 3E 20               LD		A, " "
0799 CD DC 0D            CALL	PRINT_CHAR
079C 7E                  LD		A, (HL)		; Print original value
079D CD A4 0E            CALL	PRINTHBYTE
07A0 3E 3E               LD		A, ">"
07A2 CD DC 0D            CALL	PRINT_CHAR
07A5 3E 20               LD		A, " "
07A7 CD DC 0D            CALL	PRINT_CHAR
07AA CD 44 0E            CALL	GETHEXBYTE
07AD 32 16 FE            LD		(MVADDR+4), A
07B0 3A 18 FE            LD		A, (ERRFLAG)
07B3 FE 00               CP		E_NONE
07B5 C0                  RET		NZ
07B6 3A 16 FE            LD		A, (MVADDR+4)
07B9 77                  LD		(HL), A		; Write new value
07BA CD 03 0E            CALL	PRINT_NEW_LINE
07BD 23                  INC		HL
07BE CD B5 0E            CALL	PRINTHWORD
07C1 18 CF               JR		EDIT_LP		; Only way out is type a non-hex char...
07C3 50 6F 72 74 20 53 63 61 6E 0D 0A 00 PSC_1: DEFB "Port Scan", 0Dh, 0Ah, EOS
07CF 21 C3 07    PSCOMMAND:	LD 		HL,PSC_1			;Print some messages 
07D2 CD D1 0D            CALL    PRINT_STRING
07D5 21 77 05            LD 		HL,MDC_3			;Print some messages 
07D8 CD D1 0D            CALL    PRINT_STRING
07DB 01 00 00            LD		BC, 0h
07DE AF                  XOR     A
07DF 3E 20               LD		A, " "
07E1 CD DC 0D            CALL	PRINT_CHAR  ; address - contents separator
07E4 79                  LD      A,C
07E5 CD A4 0E            CALL	PRINTHBYTE
07E8 3E 20               LD		A, " "
07EA CD DC 0D            CALL	PRINT_CHAR  ; address - contents separator
07ED CD DC 0D            CALL	PRINT_CHAR
07F0 ED 78               IN		A, (C)
07F2 CD A4 0E            CALL	PRINTHBYTE
07F5 3E 20               LD		A, " "
07F7 CD DC 0D            CALL	PRINT_CHAR ; inter-port-contents separator
07FA 03                  INC		BC
07FB AF                  XOR		A
07FC 80                  ADD		A, B
07FD 20 11               JR      NZ, PS_END  ; check for all ports done
07FF 79                  LD		A, C
0800 E6 0F               AND		00Fh	; multiples of 16
0802 20 EC               JR      NZ, PS_LOOP	; line not yet full
0804 CD 03 0E            CALL	PRINT_NEW_LINE
0807 18 D6               JR		PS_NEWPL
0809 3E 20               LD		A, " "
080B CD DC 0D            CALL	PRINT_CHAR
080E 18 E0               JR		PS_LOOP
0810 C9                  RET
0811 49 4F 20 52 65 61 64 0D 0A RIC_1: DEFB "IO Read", 0Dh, 0Ah
081A 45 6E 74 65 72 20 49 4F 20 61 64 64 72 65 73 73 2E 20 4F 6E 6C 79 20 24 30 30 6E 6E 20 73 75 70 70 6F 72 74 65 64 2E 20 27 45 4E 54 45 52 27 20 65 6E 64 73 0D 0A 00 RIC_2: DEFB "Enter IO address. Only $00nn supported. 'ENTER' ends", 0Dh, 0Ah, EOS
0851 21 11 08    RICOMMAND:        LD 		HL,RIC_1			;Print some messages 
0854 CD D1 0D            CALL    PRINT_STRING
0857 CD 44 0E    RILOOP:        CALL    GETHEXBYTE
085A 32 12 FE            LD      (MVADDR), A             ; Misuse Move address buffer to store port
085D 3A 18 FE            LD      A, (ERRFLAG)
0860 FE 00               CP      E_NONE
0862 20 15               JR      NZ,RICOUT
0864 3E 20               LD		A, " "
0866 CD DC 0D            CALL	PRINT_CHAR
0869 3A 12 FE            LD      A, (MVADDR)
086C 4F                  LD      C, A
086D 06 00               LD      B, 0
086F ED 78               IN      A, (C)
0871 CD A4 0E            CALL	PRINTHBYTE
0874 CD 03 0E            CALL	PRINT_NEW_LINE
0877 18 DE               JR      RILOOP
0879 CD 03 0E    RICOUT:        CALL	PRINT_NEW_LINE
087C C9                  RET
087D 57 72 69 74 65 20 64 61 74 61 20 74 6F 20 70 6F 72 74 0D 0A MPW_1:  DEFB    "Write data to port", 0Dh, 0Ah
0891 50 6F 72 74 20 26 20 64 61 74 61 3A 20 00 MPW_P:  DEFB    "Port & data: ", EOS
089F 21 7D 08    PW_COMMAND:	LD      HL, MPW_1
08A2 CD D1 0D            CALL    PRINT_STRING
08A5 CD 44 0E            CALL    GETHEXBYTE
08A8 32 12 FE            LD      (MVADDR), A             ; Misuse Move address buffer to store port
08AB 3A 18 FE            LD      A, (ERRFLAG)
08AE FE 00               CP      E_NONE
08B0 C0                  RET     NZ
08B1 3E 20               LD      A, " "
08B3 CD DC 0D            CALL    PRINT_CHAR
08B6 CD 44 0E            CALL    GETHEXBYTE
08B9 32 13 FE            LD      (MVADDR+1), A
08BC 3A 18 FE            LD      A, (ERRFLAG)
08BF FE 00               CP      E_NONE
08C1 C0                  RET     NZ
08C2 3A 12 FE            LD      A, (MVADDR)
08C5 4F                  LD      C, A
08C6 3A 13 FE            LD      A, (MVADDR+1)
08C9 ED 79               OUT     (C), A
08CB AF                  xor a			; zero A because upon return other commands will be tested for and value in a may trigger them
08CC C9                  RET
08CD 45 78 65 63 75 74 65 20 70 72 6F 67 72 61 6D 20 69 6E 20 6D 65 6D 6F 72 79 0D 0A 00 MGo_1:	DEFB	"Execute program in memory", 0Dh, 0Ah, EOS
08E9 4D 65 6D 6F 72 79 20 6C 6F 63 61 74 69 6F 6E 3A 20 00 MGo_2:	DEFB	"Memory location: ", EOS
08FB 21 CD 08    GO_COMMAND:	LD		HL, MGo_1	; Print some messages
08FE CD D1 0D            CALL	PRINT_STRING
0901 21 E9 08            LD		HL, MGo_2	; Print some messages
0904 CD D1 0D            CALL	PRINT_STRING
0907 CD 6C 0E            CALL	GETHEXWORD
090A 3A 18 FE            LD		A, (ERRFLAG)
090D FE 00               CP		E_NONE
090F C0                  RET		NZ
0910 E9                  JP       (HL)	; Jump
0911 43 61 6C 6C 20 70 72 6F 67 72 61 6D 20 69 6E 20 6D 65 6D 6F 72 79 0D 0A 00 MCl_1:	DEFB	"Call program in memory", 0Dh, 0Ah, EOS
092A 21 11 09    CL_COMMAND:	LD		HL, MCl_1	; Print some messages
092D CD D1 0D            CALL	PRINT_STRING
0930 21 E9 08            LD		HL, MGo_2	; Print some messages
0933 CD D1 0D            CALL	PRINT_STRING
0936 CD 6C 0E            CALL	GETHEXWORD
0939 3A 18 FE            LD		A, (ERRFLAG)
093C FE 00               CP		E_NONE
093E C0                  RET		NZ
093F 11 F3 01            LD		DE, MON_COMMAND
0942 D5                  PUSH	DE			; Add a suitable return address to the stack
0943 E9                  JP	(HL)
0944 C9                  RET
0945 43 61 6C 63 75 6C 61 74 65 20 63 68 65 63 6B 73 75 6D 20 66 6F 72 20 6D 65 6D 6F 72 79 20 72 61 6E 67 65 0D 0A 00 CCKSM_1:	DEFB	"Calculate checksum for memory range", 0Dh, 0Ah, EOS
096B 53 74 61 72 74 20 6C 6F 63 61 74 69 6F 6E 3A 20 00 CCKSM_2:	DEFB	"Start location: ", EOS
097C 45 6E 64 20 6C 6F 63 61 74 69 6F 6E 3A 20 00 CCKSM_3:	DEFB	"End location: ", EOS
098B 43 68 65 63 6B 73 75 6D 3A 20 00 CCKSM_4:    DEFB    "Checksum: ", EOS
0996 21 45 09    CCKSM_COMMAND:	LD		HL, CCKSM_1
0999 CD D1 0D            CALL	PRINT_STRING
099C 21 6B 09            LD		HL, CCKSM_2	    ; start
099F CD D1 0D            CALL	PRINT_STRING
09A2 CD 6C 0E            CALL	GETHEXWORD
09A5 3A 18 FE            LD		A, (ERRFLAG)
09A8 FE 00               CP		E_NONE
09AA C0                  RET		NZ
09AB 22 12 FE            LD      (MVADDR+0), HL
09AE CD 03 0E            CALL	PRINT_NEW_LINE
09B1 21 7C 09            LD		HL, CCKSM_3     ; end
09B4 CD D1 0D            CALL	PRINT_STRING
09B7 CD 6C 0E            CALL	GETHEXWORD
09BA 3A 18 FE            LD		A, (ERRFLAG)
09BD FE 00               CP		E_NONE
09BF C0                  RET		NZ
09C0 22 14 FE            LD      (MVADDR+2), HL
09C3 CD 03 0E            CALL	PRINT_NEW_LINE
09C6 ED 4B 12 FE         LD      BC, (MVADDR+0)  ; starting point
09CA ED 5B 14 FE         LD      DE, (MVADDR+2)  ; end point
09CE 21 00 00            LD      HL, 0           ; the checksum value
09D1 3E 00               LD      A, 0
09D3 32 24 FE            LD      (CHKSUM_C), A   ; checksum overflow
09D6 79                  LD      A, C
09D7 BB                  CP      E
09D8 20 04               JR      NZ, CCSM_3      ; on no match in LSB, skip the MSB
09DA 78                  LD      A, B
09DB BA                  CP      D
09DC 28 15               JR      Z, CCSM_4       ; MSB matches too
09DE 0A                  LD      A, (BC)
09DF 85                  ADD     A, L
09E0 6F                  LD      L, A
09E1 30 0D               JR      NC, CCSM_2      ; check carry in checksum LSB
09E3 7C                  LD      A, H
09E4 C6 01               ADD     A, 1
09E6 67                  LD      H, A
09E7 30 07               JR      NC, CCSM_2
09E9 3A 24 FE            LD      A, (CHKSUM_C)
09EC 3C                  INC     A
09ED 32 24 FE            LD      (CHKSUM_C), A
09F0 03                  INC     BC
09F1 18 E3               JR      CCSM_1
09F3 E5                  PUSH    HL
09F4 21 8B 09            LD		HL, CCKSM_4     ; end
09F7 CD D1 0D            CALL	PRINT_STRING
09FA 3A 24 FE            LD      A, (CHKSUM_C)
09FD CD A4 0E            CALL    PRINTHBYTE      ; checksum overflow first
0A00 E1                  POP     HL
0A01 CD B5 0E            CALL    PRINTHWORD
0A04 CD 03 0E            CALL    PRINT_NEW_LINE
0A07 C9                  RET
0A08 3E 01       HEXI_COMMAND:	LD      A, 1
0A0A 32 19 FE            LD      (MUTE), A
0A0D 21 2C FE            LD      HL, UPLOADBUF
0A10 22 20 FE            LD      (RX_READ_P), HL
0A13 22 22 FE            LD      (RX_WRITE_P), HL
0A16 CD D4 02    HXI_LOOP:	CALL    UART_RX_RDY
0A19 CD E2 02            CALL    UART_RX
0A1C 2A 22 FE            LD      HL, (RX_WRITE_P)
0A1F 77                  LD      (HL), A
0A20 23                  INC     HL
0A21 22 22 FE            LD      (RX_WRITE_P), HL
0A24 A7                  AND     A
0A25 FE 0A               CP      LF
0A27 28 02               JR      Z, HXI_RCVD
0A29 18 EB               JR      HXI_LOOP
0A2B 3E 00       HXI_RCVD:	LD      A, 0
0A2D 32 19 FE            LD      (MUTE), A
0A30 21 2E FE            LD      HL, UPLOADBUF + 2       ; Point to the first address char.
0A33 06 04               LD      B, 4
0A35 7E          HXIADRLP:	LD      A, (HL)
0A36 CD DC 0D            CALL    PRINT_CHAR
0A39 23                  INC     HL
0A3A 10 F9               DJNZ    HXIADRLP
0A3C 21 2C FE    HXI_PROC:	LD      HL, UPLOADBUF
0A3F CD EF 0E            CALL    CHARS2BYTE              ; get record size
0A42 32 1A FE            LD      (ULSIZE), A             ; store it
0A45 CD EF 0E            CALL    CHARS2BYTE              ; get record address, MSB
0A48 32 1D FE            LD      (IECADDR+1), A          ; 
0A4B CD EF 0E            CALL    CHARS2BYTE              ; get record address, LSB
0A4E 32 1C FE            LD      (IECADDR), A 
0A51 CD EF 0E            CALL    CHARS2BYTE              ; get record type
0A54 32 1E FE            LD      (IERECTYPE), A
0A57 FE 01               CP      01h                     ; compare to end record
0A59 28 20               JR      Z, HXI_ENDR
0A5B 3A 1A FE            LD      A, (ULSIZE)
0A5E 47                  LD      B, A                    ; set up DJNZ loop
0A5F ED 5B 1C FE         LD      DE, (IECADDR)
0A63 CD EF 0E    HXD_LOOP:	CALL    CHARS2BYTE              ; get data byte
0A66 12                  LD      (DE), A                 ; store it at target location
0A67 13                  INC     DE
0A68 10 F9               DJNZ    HXD_LOOP                ; repeat for all data bytes
0A6A 3E 20               ld a," "
0A6C CD DC 0D            CALL    PRINT_CHAR
0A6F CD EF 0E            CALL    CHARS2BYTE              ; Get checksum. Not that anyone checks it...
0A72 CD A4 0E            call PRINTHBYTE
0A75 2B                  dec hl
0A76 77                  ld (hl),a			; in case anyone wants to use checksum, store it in last byte of data buffer
0A77 CD 03 0E            CALL    PRINT_NEW_LINE
0A7A AF                  xor a	; checksum being returned in A was matching command checks, so zero A
0A7B C9          HXI_ENDR:	RET
0A7C 20 41 46 20 20 20 42 43 20 20 20 44 45 20 20 20 48 4C 20 20 20 49 58 20 20 20 49 59 20 20 20 41 46 27 20 20 42 43 27 20 20 44 45 27 20 20 48 4C 27 00 RDLN_1: DEFB    " AF   BC   DE   HL   IX   IY   AF", 027h, "  BC", 027h, "  DE", 027h, "  HL", 027h, EOS
0AAE 20 53 50 20 20 20 50 43 20 20 20 49 46 20 20 20 53 5A 2D 48 2D 50 4E 43 20 20 53 5A 2D 48 2D 50 4E 43 27 00 RDLN_3: DEFB    " SP   PC   IF   SZ-H-PNC  SZ-H-PNC", 027h  , EOS
0AD2 21 7C 0A    REGDUMP_COMMAND:	LD      HL, RDLN_1
0AD5 CD D1 0D            CALL    PRINT_STRING
0AD8 CD 03 0E            CALL    PRINT_NEW_LINE
0ADB 2A BC 1F            LD      HL, (USERAF)
0ADE CD B5 0E            CALL    PRINTHWORD
0AE1 3E 20               LD      A, " "
0AE3 CD DC 0D            CALL    PRINT_CHAR
0AE6 2A BE 1F            LD      HL, (USERBC)
0AE9 CD B5 0E            CALL    PRINTHWORD
0AEC 3E 20               LD      A, " "
0AEE CD DC 0D            CALL    PRINT_CHAR
0AF1 2A C0 1F            LD      HL, (USERDE)
0AF4 CD B5 0E            CALL    PRINTHWORD
0AF7 3E 20               LD      A, " "
0AF9 CD DC 0D            CALL    PRINT_CHAR
0AFC 2A C2 1F            LD      HL, (USERHL)
0AFF CD B5 0E            CALL    PRINTHWORD
0B02 3E 20               LD      A, " "
0B04 CD DC 0D            CALL    PRINT_CHAR
0B07 2A CC 1F            LD      HL, (USERIX)
0B0A CD B5 0E            CALL    PRINTHWORD
0B0D 3E 20               LD      A, " "
0B0F CD DC 0D            CALL    PRINT_CHAR
0B12 2A CE 1F            LD      HL, (USERIY)
0B15 CD B5 0E            CALL    PRINTHWORD
0B18 3E 20               LD      A, " "
0B1A CD DC 0D            CALL    PRINT_CHAR
0B1D 2A C4 1F            LD      HL, (UAFP)
0B20 CD B5 0E            CALL    PRINTHWORD
0B23 3E 20               LD      A, " "
0B25 CD DC 0D            CALL    PRINT_CHAR
0B28 2A C6 1F            LD      HL, (UBCP)
0B2B CD B5 0E            CALL    PRINTHWORD
0B2E 3E 20               LD      A, " "
0B30 CD DC 0D            CALL    PRINT_CHAR
0B33 2A C8 1F            LD      HL, (UDEP)
0B36 CD B5 0E            CALL    PRINTHWORD
0B39 3E 20               LD      A, " "
0B3B CD DC 0D            CALL    PRINT_CHAR
0B3E 2A CA 1F            LD      HL, (UHLP)
0B41 CD B5 0E            CALL    PRINTHWORD
0B44 3E 20               LD      A, " "
0B46 CD DC 0D            CALL    PRINT_CHAR
0B49 CD 03 0E            CALL    PRINT_NEW_LINE
0B4C 21 AE 0A            LD      HL, RDLN_3
0B4F CD D1 0D            CALL    PRINT_STRING
0B52 CD 03 0E            CALL    PRINT_NEW_LINE
0B55 2A D0 1F            LD      HL, (USERSP)
0B58 CD B5 0E            CALL    PRINTHWORD
0B5B 3E 20               LD      A, " "
0B5D CD DC 0D            CALL    PRINT_CHAR
0B60 2A DC 1F            LD      HL, (USERPC)
0B63 CD B5 0E            CALL    PRINTHWORD
0B66 3E 20               LD      A, " "
0B68 CD DC 0D            CALL    PRINT_CHAR
0B6B 2A D2 1F            LD      HL, (USERIF)
0B6E CD B5 0E            CALL    PRINTHWORD
0B71 3E 20               LD      A, " "
0B73 CD DC 0D            CALL    PRINT_CHAR
0B76 CD DC 0D            CALL    PRINT_CHAR
0B79 3A BD 1F            LD      A, (USERAF+1)
0B7C CD DF 0E            CALL    PRT8BIT
0B7F 3E 20               LD      A, " "
0B81 CD DC 0D            CALL    PRINT_CHAR
0B84 3E 20               LD      A, " "
0B86 CD DC 0D            CALL    PRINT_CHAR
0B89 3A C5 1F            LD      A, (UAFP+1)
0B8C CD DF 0E            CALL    PRT8BIT
0B8F C9                  RET
0B90 CD D2 0A            CALL    REGDUMP_COMMAND
0B93 C3 00 00            JP      MPFMON  ; return to monitor
0B96 52 41 4D 20 54 65 73 74 0D 0A 00 TRC_1: DEFB "RAM Test", 0Dh, 0Ah, EOS
0BA1 4C 6F 63 61 74 69 6F 6E 20 74 6F 20 73 74 61 72 74 20 69 6E 20 34 20 64 69 67 69 74 20 48 45 58 3A 20 00 TRC_2: DEFB "Location to start in 4 digit HEX: ", EOS
0BC4 0D 0A 4C 6F 63 61 74 69 6F 6E 20 74 6F 20 65 6E 64 20 69 6E 20 34 20 64 69 67 69 74 20 48 45 58 3A 20 00 TRC_3: DEFB 0Dh, 0Ah, "Location to end in 4 digit HEX: ", EOS
0BE7 0D 0A 53 74 61 72 74 20 61 64 64 72 65 73 73 20 73 68 6F 75 6C 64 20 62 65 20 62 65 66 6F 72 65 20 45 6E 64 20 61 64 64 72 65 73 73 00 TRC_4: DEFB 0Dh, 0Ah, "Start address should be before End address", EOS
0C14 21 96 0B    TRAM_COMMAND:	LD      HL,TRC_1        ;Print some messages 
0C17 CD D1 0D            CALL    PRINT_STRING
0C1A 21 A1 0B            LD      HL,TRC_2
0C1D CD D1 0D            CALL    PRINT_STRING
0C20 CD 6C 0E            CALL    GETHEXWORD              ;HL now points to databyte location	
0C23 22 12 FE            LD      (MVADDR), HL
0C26 21 C4 0B            LD      HL,TRC_3
0C29 CD D1 0D            CALL    PRINT_STRING
0C2C CD 6C 0E            CALL    GETHEXWORD              ;HL now points to databyte location	
0C2F 22 14 FE            LD      (MVADDR+2), HL
0C32 3A 15 FE            LD      A, (MVADDR+3)   ; End MSB
0C35 21 13 FE            LD      HL, MVADDR+1    ; (Start MSB)
0C38 BE                  CP      (HL)            ; A - (HL)
0C39 28 07               JR      Z, _TC_ZERO     ; When MSBs are on same page, test LSBs
0C3B 38 13               JR      C, _TC_NEGM      ; When Start MSB > End MSB, report error, exit
0C3D CD EA 0C            CALL    MTEST           ; When End page (MSB) is larger than Start (MSB), go to test
0C40 18 16               JR      _TC_DONE
0C42 3A 14 FE            LD      A, (MVADDR+2)   ; End LSB
0C45 21 12 FE            LD      HL, MVADDR+0    ; (Start LSB)
0C48 BE                  CP      (HL)            ; A - (HL)
0C49 38 05               JR      C, _TC_NEGL      ; When Start LSB > End LSB, report error, exit
0C4B CD EA 0C            CALL    MTEST           ; When End page (LSB) is larger than Start (LSB), go to test
0C4E 18 08               JR      _TC_DONE
0C50 21 E7 0B            LD      HL, TRC_4
0C53 CD D1 0D            CALL    PRINT_STRING
0C56 18 00               JR      _TC_DONE
0C58 C9                  RET
0C59 0D 0A 20 50 61 73 73 20 31 3A 20 3F 3F 68 20 74 6F 20 30 30 68 20 00 MTC_1: DEFB 0Dh, 0Ah, " Pass 1: ??h to 00h ", EOS
0C70 0D 0A 20 50 61 73 73 20 32 3A 20 30 30 68 20 74 6F 20 35 35 68 20 00 MTC_2: DEFB 0Dh, 0Ah, " Pass 2: 00h to 55h ", EOS
0C87 0D 0A 20 50 61 73 73 20 33 3A 20 35 35 68 20 74 6F 20 41 41 68 20 00 MTC_3: DEFB 0Dh, 0Ah, " Pass 3: 55h to AAh ", EOS
0C9E 0D 0A 20 50 61 73 73 20 34 3A 20 41 41 68 20 74 6F 20 46 46 68 20 00 MTC_4: DEFB 0Dh, 0Ah, " Pass 4: AAh to FFh ", EOS
0CB5 0D 0A 20 4D 65 6D 6F 72 79 20 4F 4B 00 MTC_5: DEFB 0Dh, 0Ah, " Memory OK", EOS
0CC2 20 45 72 72 6F 72 20 61 74 3A 20 00 MTCER1: DEFB " Error at: ", EOS
0CCE 20 76 61 6C 75 65 20 65 78 70 65 63 74 65 64 3A 20 00 MTCER2: DEFB " value expected: ", EOS
0CE0 2C 20 66 6F 75 6E 64 3A 20 00 MTCER3: DEFB ", found: ", EOS
0CEA DD 21 12 FE MTEST:	LD      IX, MVADDR
0CEE 21 59 0C            LD      HL, MTC_1
0CF1 CD D1 0D            CALL    PRINT_STRING
0CF4 2A 12 FE            LD      HL, (MVADDR+0)
0CF7 ED 4B 14 FE         LD      BC, (MVADDR+2)
0CFB 1E 40               LD      E, 64
0CFD 16 00               LD      D, 000h
0CFF 3E 01               LD      A, 1
0D01 32 1F FE            LD      (MTPHFLAG), A
0D04 CD 55 0D            CALL    MCHECK
0D07 38 4B               JR      C, _MTDONE      ; skip other tests on error
0D09 21 70 0C            LD      HL, MTC_2
0D0C CD D1 0D            CALL    PRINT_STRING
0D0F 2A 12 FE            LD      HL, (MVADDR+0)  ; reset start address
0D12 1E 00               LD      E, 000h         ; old value
0D14 16 55               LD      D, 055h         ; new value
0D16 3E 02               LD      A, 2
0D18 32 1F FE            LD      (MTPHFLAG), A
0D1B CD 55 0D            CALL    MCHECK
0D1E 38 34               JR      C, _MTDONE      ; skip other tests on error
0D20 21 87 0C            LD      HL, MTC_3
0D23 CD D1 0D            CALL    PRINT_STRING
0D26 2A 12 FE            LD      HL, (MVADDR+0)  ; reset start address
0D29 1E 55               LD      E, 055h         ; old value
0D2B 16 AA               LD      D, 0AAh         ; new value
0D2D 3E 03               LD      A, 3
0D2F 32 1F FE            LD      (MTPHFLAG), A
0D32 CD 55 0D            CALL    MCHECK
0D35 38 1D               JR      C, _MTDONE      ; skip other tests on error
0D37 21 9E 0C            LD      HL, MTC_4
0D3A CD D1 0D            CALL    PRINT_STRING
0D3D 2A 12 FE            LD      HL, (MVADDR+0)  ; reset start address
0D40 1E AA               LD      E, 0AAh         ; old value
0D42 16 FF               LD      D, 0FFh         ; new value
0D44 3E 04               LD      A, 4
0D46 32 1F FE            LD      (MTPHFLAG), A
0D49 CD 55 0D            CALL    MCHECK
0D4C 38 06               JR      C, _MTDONE      ; skip other tests on error
0D4E 21 B5 0C            LD      HL, MTC_5       ; Ok text
0D51 CD D1 0D            CALL    PRINT_STRING        
0D54 C9                  RET
0D55 3A 1F FE            LD      A, (MTPHFLAG)
0D58 FE 01               CP      1
0D5A 28 0D               JR      Z, _MCSKIPOLD   ; Skip old value check for pass 1
0D5C 7B                  LD      A, E
0D5D DD 77 05            LD      (IX+5), A       ; store expected value
0D60 7E                  LD      A, (HL)         ; read mem
0D61 DD 77 04            LD      (IX+4), A       ; store actual value
0D64 DD BE 05            CP      (IX+5)          ; compare with expected
0D67 20 19               JR      NZ, _MTLPER1    ; jump to error when unequal
0D69 7A                  LD      A, D
0D6A 77                  LD      (HL), A         ; write new value
0D6B DD 77 05            LD      (IX+5), A       ; store expected value
0D6E 7E                  LD      A, (HL)         ; read new value
0D6F DD 77 04            LD      (IX+4), A       ; store actual value
0D72 DD BE 05            CP      (IX+5)          ; compare with expected
0D75 20 1C               JR      NZ, _MTLPER2    ; jump to error when unequal
0D77 CD CA 0D            CALL    CPADDR          ; 
0D7A 23                  INC     HL              ; 
0D7B 20 D8               JR      NZ, _MCLOOP     ; 
0D7D A7                  AND     A               ; "Clear Carry flag"
0D7E 3E 01               LD      A, 1
0D80 18 47               JR      _MCDONE
0D82 F5                  PUSH    AF
0D83 CD 03 0E            CALL    PRINT_NEW_LINE
0D86 3E 31               LD      A, "1"
0D88 CD DC 0D            CALL    PRINT_CHAR
0D8B 3E 2E               LD      A, "."
0D8D CD DC 0D            CALL    PRINT_CHAR
0D90 F1                  POP     AF
0D91 18 0F               JR      _MTLPER
0D93 F5                  PUSH    AF
0D94 CD 03 0E            CALL    PRINT_NEW_LINE
0D97 3E 32               LD      A, "2"
0D99 CD DC 0D            CALL    PRINT_CHAR
0D9C 3E 2E               LD      A, "."
0D9E CD DC 0D            CALL    PRINT_CHAR
0DA1 F1                  POP     AF
0DA2 E5                  PUSH    HL              ; keep actual location
0DA3 21 C2 0C            LD      HL, MTCER1      ; at text
0DA6 CD D1 0D            CALL    PRINT_STRING
0DA9 E1                  POP     HL
0DAA CD B5 0E            CALL    PRINTHWORD
0DAD 21 CE 0C            LD      HL, MTCER2      ; expected text
0DB0 CD D1 0D            CALL    PRINT_STRING
0DB3 3A 17 FE            LD      A, (MVADDR+5)   ; expected value
0DB6 CD A4 0E            CALL    PRINTHBYTE
0DB9 21 E0 0C            LD      HL, MTCER3      ; actual found text
0DBC CD D1 0D            CALL    PRINT_STRING
0DBF 3A 16 FE            LD      A, (MVADDR+4)   ; actual value
0DC2 CD A4 0E            CALL    PRINTHBYTE
0DC5 CD 03 0E            CALL    PRINT_NEW_LINE
0DC8 37                  SCF                     ; Flag the error for calling routine
0DC9 C9                  RET
0DCA 78          CPADDR:	LD      A, B        ; End MSB
0DCB BC                  CP      H           ; end MSB - current MSB : B - H
0DCC 20 02               JR      NZ, _CPDONE ; When MSBs are unequal
0DCE 79                  LD      A, C        ; End LSB
0DCF BD                  CP      L           ; end LSB - current LSB ; C - L
0DD0 C9                  RET
# End of file C:\zeus\mintz80_monitor\MONCommands.asm
# File C:\zeus\mintz80_monitor\CONIO.asm
0DD1 CD B7 02            CALL    UART_PRNT_STR
0DD4 C9                  RET
0DD5 CD E2 02    GET_CHAR:	CALL    UART_RX         ;Get char into Acc
0DD8 CD EE 0D            CALL    TO_UPPER        ;Character has to be upper case
0DDB C9                  RET
0DDC CD CE 02    PRINT_CHAR:	CALL UART_TX    ;Echo character to terminal
0DDF C9                  RET
0DE0 4F                  LD      C, A
0DE1 3A 19 FE            LD      A, (MUTE)
0DE4 FE 01               CP      MUTEON  ; compare with 1=true
0DE6 28 04               JR      Z, PRTSKIP
0DE8 79                  LD      A, C
0DE9 CD DC 0D            CALL    PRINT_CHAR
0DEC 79                  LD      A, C
0DED C9                  RET
0DEE FE 61               CP      "a"     ; Nothing to do if not lower case
0DF0 D8                  RET     C
0DF1 FE 7B               CP      "z" + 1 ; > "z"?
0DF3 D0                  RET     NC      ; Nothing to do, either
0DF4 E6 5F               AND     5Fh     ; Convert to upper case
0DF6 C9                  RET
0DF7 FE 20               CP      LOWPRTV
0DF9 38 05               JR      C, ADDOT
0DFB FE 7E               CP      HIGPRTV
0DFD 30 01               JR      NC, ADDOT
0DFF C9                  RET
0E00 3E 2E               LD      A, "."
0E02 C9                  RET
0E03 F5                  PUSH    af
0E04 3E 0D               LD      A, $0d
0E06 CD DC 0D            CALL    PRINT_CHAR
0E09 3E 0A               LD      A, $0a
0E0B CD DC 0D            CALL    PRINT_CHAR
0E0E F1                  POP     af
0E0F C9                  RET
0E10 FE 47               CP      "F" + 1         ;(Acc) > "F"? 
0E12 D0                  RET     NC              ;Yes - Return / No - Continue
0E13 FE 30               CP      "0"             ;(Acc) < "0"?
0E15 D2 1A 0E            JP      NC,CIH1         ;Yes - Jump / No - Continue
0E18 3F                  CCF                     ;Complement carry (clear it)
0E19 C9                  RET
0E1A FE 3A               CP      "9" + 1         ;(Acc) < "9" + 1?
0E1C D8                  RET     C               ;Yes - Return / No - Continue (meaning Acc between "0" and "9")
0E1D FE 41               CP      "A"             ;(Acc) > "A"?
0E1F D2 24 0E            JP      NC,CIH2         ;Yes - Jump / No - Continue
0E22 3F                  CCF                     ;Complement carry (clear it)
0E23 C9                  RET
0E24 37                  SCF                     ;Set carry flag to indicate the char is a hex digit
0E25 C9                  RET
0E26 CD D5 0D            CALL    GET_CHAR
0E29 CD 10 0E            CALL    CHAR_ISHEX      ; Is it a hex digit?
0E2C D2 3E 0E            JP      NC,NONHEXNIB    ; Yes - Continue / No - Exit
0E2F CD E0 0D            CALL    OPRINTCHAR
0E32 FE 3A               CP      "9" + 1         ; Is it a digit less or equal "9" + 1?
0E34 DA 39 0E            JP      C,IS_NUM        ; Yes - Jump / No - Continue
0E37 D6 07               SUB     07h             ; Adjust for A-F digits
0E39 D6 30               SUB     "0"             ; Subtract to get nib between 0->15
0E3B E6 0F               AND     0Fh             ; Only return lower 4 bits
0E3D C9                  RET
0E3E 3E 01               LD      A, E_NOHEX
0E40 32 18 FE            LD      (ERRFLAG), A    ; Error flag
0E43 C9                  RET
0E44 CD 26 0E            CALL    GETHEXNIB       ; Get high nibble
0E47 D5                  PUSH	DE
0E48 F5                  PUSH	AF
0E49 3A 18 FE            LD	A, (ERRFLAG)
0E4C FE 00               CP	E_NONE
0E4E 20 19               JR	NZ, GHB_ERR
0E50 F1                  POP	AF
0E51 CB 07               RLC     A               ; Rotate nibble into high nibble
0E53 CB 07               RLC     A
0E55 CB 07               RLC     A
0E57 CB 07               RLC     A
0E59 57                  LD      D,A             ; Save upper four bits
0E5A CD 26 0E            CALL    GETHEXNIB       ; Get lower nibble
0E5D F5                  PUSH	AF
0E5E 3A 18 FE            LD	A, (ERRFLAG)
0E61 FE 00               CP	E_NONE
0E63 20 04               JR	NZ, GHB_ERR  
0E65 F1                  POP	AF          
0E66 B2                  OR      D               ; Combine both nibbles
0E67 D1                  POP	DE
0E68 C9                  RET
0E69 F1                  POP	AF
0E6A D1                  POP	DE
0E6B C9                  RET
0E6C CD 44 0E            CALL    GETHEXBYTE	;Get high byte
0E6F F5                  PUSH	AF
0E70 3A 18 FE            LD		A, (ERRFLAG)
0E73 FE 00               CP		E_NONE
0E75 20 10               JR		NZ, GHW_ERR
0E77 F1                  POP		AF
0E78 67                  LD		H,A
0E79 CD 44 0E            CALL    GETHEXBYTE    	;Get low byte
0E7C F5                  PUSH	AF
0E7D 3A 18 FE            LD		A, (ERRFLAG)
0E80 FE 00               CP		E_NONE
0E82 20 03               JR		NZ, GHW_ERR
0E84 F1                  POP     AF
0E85 6F                  LD      L,A
0E86 C9                  RET
0E87 F1                  POP		AF
0E88 C9                  RET
0E89 E6 0F               AND     0Fh             	;Only low nibble in byte
0E8B C6 30               ADD     A,"0"             	;Adjust for char offset
0E8D FE 3A               CP      "9" + 1         	;Is the hex digit > 9?
0E8F 38 02               JR      C,N2C1				;Yes - Jump / No - Continue
0E91 C6 07               ADD     A,"A" - "0" - 0Ah 	;Adjust for A-F
0E93 C9                  RET
0E94 E6 F0               AND     0F0h
0E96 0F                  RRCA
0E97 0F                  RRCA
0E98 0F                  RRCA
0E99 0F                  RRCA
0E9A C9                  RET
0E9B F5                  PUSH    AF
0E9C CD 89 0E            CALL    NIB2CHAR
0E9F CD DC 0D            CALL    PRINT_CHAR        	;Print the nibble
0EA2 F1                  POP     AF
0EA3 C9                  RET
0EA4 F5                  PUSH    AF      ;Save registers
0EA5 D5                  PUSH    DE
0EA6 57                  LD      D,A     ;Save for low nibble
0EA7 0F                  RRCA            ;Rotate high nibble into low nibble
0EA8 0F                  RRCA
0EA9 0F                  RRCA
0EAA 0F                  RRCA
0EAB CD 9B 0E            CALL    PRINTHNIB       ;Print high nibble
0EAE 7A                  LD      A,D             ;Restore for low nibble
0EAF CD 9B 0E            CALL    PRINTHNIB       ;Print low nibble
0EB2 D1                  POP     DE
0EB3 F1                  POP     AF
0EB4 C9                  RET
0EB5 F5                  PUSH    AF
0EB6 7C                  LD      A,H
0EB7 CD A4 0E            CALL    PRINTHBYTE      ;Print high byte
0EBA 7D                  LD      A,L
0EBB CD A4 0E            CALL    PRINTHBYTE      ;Print low byte
0EBE F1                  POP     AF
0EBF C9                  RET
0EC0 D6 30               SUB     "0"
0EC2 FE 0A               CP      0ah
0EC4 38 08               JR      C, C2N_DONE
0EC6 D6 07               SUB     007h
0EC8 FE 10               CP      010h			; need to deduct 20h if it was lower case letter
0ECA 38 02               JR      C, C2N_DONE
0ECC D6 20               SUB     020h
0ECE E6 0F               AND     0Fh
0ED0 C9                  RET
0ED1 38 04               JR      C, PB0
0ED3 3E 31               LD      A, "1"
0ED5 18 04               JR      PBPRT
0ED7 3E 30               LD      A, "0"
0ED9 18 00               JR      PBPRT 
0EDB CD DC 0D            CALL    PRINT_CHAR
0EDE C9                  RET
0EDF 4F                  LD      C, A
0EE0 06 08               LD      B, 8
0EE2 CB 07               RLC     A
0EE4 4F                  LD      C, A
0EE5 CD D1 0E            CALL    PRTBIT
0EE8 05                  DEC     B
0EE9 28 03               JR      Z, P8B_RET
0EEB 79                  LD      A, C
0EEC 18 F4               JR      P8B1
0EEE C9                  RET
0EEF C5                  PUSH    BC
0EF0 7E                  LD      A, (HL)
0EF1 23                  INC     HL
0EF2 CD C0 0E            CALL    CHAR2NIB        ; get upper nibble from char
0EF5 CB 07               RLC     A
0EF7 CB 07               RLC     A
0EF9 CB 07               RLC     A
0EFB CB 07               RLC     A
0EFD 47                  LD      B, A
0EFE 7E                  LD      A, (HL)
0EFF 23                  INC     HL
0F00 CD C0 0E            CALL    CHAR2NIB        ; get lower nibble from char
0F03 B0                  OR      B
0F04 C1                  POP     BC
0F05 C9                  RET
# End of file C:\zeus\mintz80_monitor\CONIO.asm
# File C:\zeus\mintz80_monitor\Z80Monitor.asm
0F06 0C 00       MON_CLS: DEFB 0Ch, EOS  				;Escape sequence for CLS. (aka form feed) 
0F08 3E 00       del00:	ld a,$00		; delay loop
0F0A F5          delay:	push af			; count delay
0F0B 3D          del1:	dec a
0F0C 20 FD       	jr nz,del1		; repeat till 0
0F0E F1          	pop af
0F0F 3D          	dec a
0F10 20 F8       	jr nz,delay
0F12 C9          	ret
0F13 F5          beep:	push af
0F14 D3 D1       bep1:	out (beepr),a
0F16 F1          	pop af
0F17 F5          	push af
0F18 CD 0A 0F    	call delay
0F1B 0B          	dec bc
0F1C 78          	ld a,b
0F1D B1          	or c
0F1E 20 F4       	jr nz,bep1
0F20 F1          	pop af
0F21 C9          	ret
0F22 0E D0       dmpio:	ld c,$d0
0F24 06 00       		ld b,$0
0F26 CD 03 0E    		CALL	PRINT_NEW_LINE
0F29 ED 78       dmpio1:	IN      A, (C)
0F2B CD A4 0E    		CALL	PRINTHBYTE
0F2E 0C          		inc c
0F2F 79          		ld a,c
0F30 FE E0       		cp $e0
0F32 20 F5       		jr nz,dmpio1
0F34 CD 03 0E    		CALL	PRINT_NEW_LINE
0F37 C9          		ret
0F38 DB D1       memmap_init:	in a,(beepr)	; unlock memmap
0F3A 3E 00       	ld a,0		; init mem map
0F3C D3 D8       	out ($d8),a
0F3E 3E 01       	ld a,1
0F40 D3 D9       	out ($d9),a
0F42 D3 DA       	out ($da),a
0F44 D3 DB       	out ($db),a
0F46 D3 DC       	out ($dc),a
0F48 D3 DD       	out ($dd),a
0F4A D3 DE       	out ($de),a
0F4C D3 DF       	out ($df),a
0F4E D3 D1       	out (beepr),a	; lock memmap
0F50 C9          	ret
# End of file C:\zeus\mintz80_monitor\Z80Monitor.asm
# File C:\zeus\mintz80_monitor\aydrvr.asm
0F51 E5          ayinit:		push hl
0F52 C5          	push bc
0F53 F5          	push af
0F54 21 81 0F    	ld hl,aytab+15
0F57 06 0F       	ld b,$0f
0F59 78          ayini1:	ld a,b
0F5A CD 66 0F    	call aywr
0F5D 2B          	dec hl
0F5E 05          	dec b
0F5F F2 59 0F    	jp p,ayini1
0F62 F1          	pop af
0F63 C1          	pop bc
0F64 E1          	pop hl
0F65 C9          	ret
0F66 D3 00       aywr:	out (aybase),a
0F68 7E          	ld a,(hl)
0F69 D3 01       	out (aybase+1),a
0F6B C9          	ret
0F6C D3 00       aysetreg: out (aybase),a
0F6E 79          	ld a,c
0F6F D3 01       	out (aybase+1),a
0F71 C9          	ret
0F72 00 00 00 00 00 00 00 F8 0F 0F 0F 00 00 00 00 00 aytab:	defb 0,0,0,0,0,0,0,$f8,$f,$f,$f,0,0,0,0,0
0F82 F5          ayblink:	push af
0F83 C5          	push bc
0F84 0E 00       	ld c,$0
0F86 3E 0E       ayblnk:	ld a,$0e
0F88 CD 6C 0F    	call aysetreg
0F8B 3E A0       	ld a,$a0
0F8D CD 0A 0F    	call delay		; looks like Z80 needs this delay to successfully write to IO ports
0F90 0C          	inc c
0F91 20 F3       	jr nz,ayblnk
0F93 3E 0E       	ld a,$0e
0F95 CD 6C 0F    	call aysetreg
0F98 C1          	pop bc
0F99 F1          	pop af
0F9A C9          	ret
# End of file C:\zeus\mintz80_monitor\aydrvr.asm
# File C:\zeus\mintz80_monitor\eeprom_prog.asm
0F9B 0D 0A 41 64 64 72 65 73 73 20 6F 66 20 73 6F 75 72 63 65 20 64 61 74 61 20 00 epp_srcaddr:	db $0d,$0a,"Address of source data ",0
0FB5 0D 0A 41 64 64 72 65 73 73 20 6F 66 20 64 65 73 74 69 6E 61 74 69 6F 6E 20 00 epp_tgtaddr:	db $0d,$0a,"Address of destination ",0
0FCF 0D 0A 44 61 74 61 20 6C 65 6E 67 74 68 20 00 epp_numbyte:	db $0d,$0a,"Data length ",0
0FDE 0D 0A 50 61 67 65 20 74 6F 20 77 72 69 74 65 20 74 6F 20 28 30 30 20 6F 72 20 30 32 29 20 00 epp_page:		db $0d,$0a,"Page to write to (00 or 02) ",0
0FFD E5          epp_prep	push hl
0FFE D5          		push de
0FFF C5          		push bc
1000 21 61 10    		ld hl,epp_prog
1003 11 00 FF    		ld de,epp_tmp
1006 01 4F 00    		ld bc,epp_end-epp_prog
1009 ED B0       		ldir
100B C1          		pop bc
100C D1          		pop de
100D E1          		pop hl
100E C9          		ret
100F E5          epp_upda:	push hl
1010 F5          		push af
1011 21 9B 0F    		ld hl,epp_srcaddr
1014 CD D1 0D    		call PRINT_STRING
1017 CD 6C 0E    		call GETHEXWORD
101A 3A 18 FE    		LD A, (ERRFLAG)
101D FE 00       		CP E_NONE
101F C0          		RET NZ
1020 22 0C FF    		ld (epp_tmp+epp_srca-epp_prog+1),hl
1023 21 B5 0F    		ld hl,epp_tgtaddr
1026 CD D1 0D    		call PRINT_STRING
1029 CD 6C 0E    		call GETHEXWORD
102C 3A 18 FE    		LD A, (ERRFLAG)
102F FE 00       		CP E_NONE
1031 20 03       		jr NZ,epp_upd1		; skip if invalid entry
1033 22 09 FF    		ld (epp_tmp+epp_tgta-epp_prog+1),hl
1036 21 CF 0F    epp_upd1:	ld hl,epp_numbyte
1039 CD D1 0D    		call PRINT_STRING
103C CD 6C 0E    		call GETHEXWORD
103F 3A 18 FE    		LD A, (ERRFLAG)
1042 FE 00       		CP E_NONE
1044 20 03       		jr NZ,epp_upd2		; skip if invalid entry
1046 22 0F FF    		ld (epp_tmp+epp_lena-epp_prog+1),hl
1049 21 DE 0F    epp_upd2:	ld hl,epp_page
104C CD D1 0D    		call PRINT_STRING
104F CD 44 0E    		call GETHEXBYTE
1052 6F          		ld l,a			; save temporarily
1053 3A 18 FE    		LD A, (ERRFLAG)
1056 FE 00       		CP E_NONE
1058 20 04       		jr NZ,epp_upd3		; skip if invalid entry
105A 7D          		ld a,l			; restore
105B 32 05 FF    		ld (epp_tmp+epp_banka-epp_prog+1),a
105E F1          epp_upd3:	pop af
105F E1          		pop hl
1060 C9          		ret
1061 E5          epp_prog:	push hl
1062 D5          		push de
1063 C5          		push bc
1064 F5          		push af
1065 3E 02       epp_banka:	ld a,epp_bank	; by default program second bank of boot EEPROM and jump to it.
1067 D3 D8       		out (memmap),a	; if programming fails, can just reset and boot to previous EEPROM
1069 21 00 00    epp_tgta:	ld hl,epp_tgt	; source of data to be programmed
106C 11 00 20    epp_srca:	ld de,epp_src	; target address
106F 01 00 20    epp_lena:	ld bc,epp_len	; number of bytes
1072 78          epp_p1:	ld a,b		; check if remaining bytes = 0
1073 B1          		or c
1074 28 18       		jr z,epp_exit	; yes, end the procedure
1076 1A          		ld a,(de)		; no, fetch next byte
1077 77          		ld (hl),a		; store it in target address
1078 F5          epp_p2:	push af		; save programmed byte
1079 D3 D1       		out (beepr),a
107B 3E 1B       		ld a,epp_del	; delay before reading back byte
107D F5          epp_delay:	push af			; count delay
107E 3D          epp_del1:	dec a
107F 20 FD       		jr nz,epp_del1		; repeat till 0
1081 F1          		pop af
1082 3D          		dec a
1083 20 F8       		jr nz,epp_delay
1085 F1          		pop af		; restore programmed byte
1086 BE          		cp (hl)		; compare with EEPROM content
1087 20 EF       		jr nz,epp_p2	; repeat till readback = programmed data
1089 23          		inc hl
108A 13          		inc de
108B 0B          		dec bc
108C 18 E4       		jr epp_p1
108E 22 60 FF    epp_exit:	ld ($ff60),hl
1091 ED 53 62 FF 		ld ($ff62),de
1095 ED 43 64 FF 		ld ($ff64),bc
1099 32 66 FF    		ld ($ff66),a
109C F1          		pop af
109D C1          		pop bc
109E D1          		pop de
109F E1          		pop hl
10A0 C3 00 00    		jp $0000		; since we've potentially changed the location of code that got us here, just start over
10A3 06 00       deltest:	ld b,0
10A5 D3 D1       dt1:		out (beepr),a
10A7 3E 1B       		ld a,epp_del	; delay before reading back byte
10A9 CD 7D 10    		call epp_delay	; about 100ms
10AC 05          		dec b
10AD 20 F6       		jr nz,dt1
10AF C9          		ret
# End of file C:\zeus\mintz80_monitor\eeprom_prog.asm
# File C:\zeus\mintz80_monitor\eeprom_write.asm
10B0 3E 01       main:		ld a,$01			; write to first page of ram
10B2 D3 D8       		out (memmap),a
10B4 CD BA 10    mainc:	call main1			; first entry point, write new eeprom code to RAM and restart system
10B7 C3 00 00    		jp 0				; if something goes wrong, resetting will boot from old code in bank 0
10BA F5          main1:	push af			; enter here for custom values of source, target and size
10BB E5          		push hl
10BC D5          		push de
10BD C5          		push bc
10BE 21 00 00    		ld hl,0			; destination starts at 0
10C1 11 00 40    		ld de,$4000		; source starts at $4000
10C4 01 00 20    		ld bc,$2000		; size of data
10C7 1A          lp1:		ld a,(de)			; fetch a byte
10C8 77          		ld (hl),a			; write to eeprom
10C9 CD DB 10    lp2:		call eewr_dly			; wait a bit
10CC BE          		cp (hl)			; check if write completed. read data should equal written data
10CD 20 FA       		jr nz,lp2			; if not, wait and test again
10CF 23          		inc hl			; otherwise point to next byte
10D0 13          		inc de
10D1 0B          		dec bc
10D2 78          		ld a,b			; check if data counter = 0
10D3 B1          		or c
10D4 20 F1       		jr nz,lp1			; no, continue loop
10D6 C1          		pop bc
10D7 D1          		pop de
10D8 E1          		pop hl
10D9 F1          		pop af
10DA C9          		ret
10DB C5          eewr_dly:	push bc
10DC 01 01 00    		ld bc,1
10DF 10 FE       eewr_lp1:	djnz eewr_lp1
10E1 0D                  dec c
10E2 20 FB               jr nz,eewr_lp1
10E4 C1                  pop bc
10E5 C9                  ret
10E6 F5          eewr_ldr:		push af
10E7 E5          		push hl
10E8 D5          		push de
10E9 C5          		push bc
10EA 11 00 20    		ld de,$2000		; relocate eeprom writer to $2000
10ED 21 B0 10    		ld hl,main			; start of code to be copied
10F0 01 36 00    		ld bc,eewr_ldr-main		; length
10F3 ED B0       		ldir				; copy code
10F5 01 00 20    		ld bc,$2000
10F8 21 2B 00    		ld hl,eewr_dly-main		; calculate target address of delay loop
10FB 09          		add hl,bc
10FC 22 1A 20    		ld (lp2-main+$2001),hl	; update call instruction with new address
10FF 21 0A 00    		ld hl,main1-main		; calculate target address of main1
1102 09          		add hl,bc
1103 22 05 20    		ld (mainc-main+$2001),hl	; update call instruction with new address
1106 C1          		pop bc
1107 D1          		pop de
1108 E1          		pop hl
1109 F1          		pop af
110A C9          		ret
# End of file C:\zeus\mintz80_monitor\eeprom_write.asm
